{-# LANGUAGE OverloadedStrings #-}
module Transform (transformToCypher) where

import           Notion.Model
import           Cypher.Emit
import qualified Data.HashMap.Strict as HM
import qualified Data.Text as T

transformToCypher :: T.Text -> DatabaseQuery -> T.Text
transformToCypher pageLabel dq =
  T.intercalate "\n" $
    [ "/* generated by notion-to-memgraph */" ] ++
    concatMap (emitPage pageLabel) (dqResults dq)

emitPage :: T.Text -> Page -> [T.Text]
emitPage pageLabel p =
  let lblPage = sanitizeLabel pageLabel
      pageNode = T.concat
        [ "MERGE (p:", lblPage, " {id: ", emitString (pageId p), "})"
        , "\nSET p += "
        , emitMap (pageBaseProps p <> pageScalarProps (pageProperties p))
        , ";\n"
        ]
      rels = concat
        [ emitSelectRels lblPage (pageId p) (pageProperties p)
        , emitPeopleRels lblPage (pageId p) (pageProperties p)
        , emitRelationRels lblPage (pageId p) (pageProperties p)
        ]
  in [pageNode] <> rels

pageBaseProps :: Page -> [(T.Text, CyVal)]
pageBaseProps p =
  [ ("url",      CyS (pageUrl p))
  , ("archived", CyB (pageArchived p))
  , ("created_time", CyS (pageCreatedTime p))
  , ("last_edited_time", CyS (pageLastEdited p))
  ] <> maybeTitle
  where
    maybeTitle =
      case firstTitle (pageProperties p) of
        Nothing -> []
        Just t  -> [("title", CyS t)]

firstTitle :: HM.HashMap T.Text PropertyValue -> Maybe T.Text
firstTitle props =
  let titles = [ T.concat (map rtPlain rts) | PVTitle rts <- HM.elems props ]
  in case titles of
       (x:_) -> Just x
       _     -> Nothing

pageScalarProps :: HM.HashMap T.Text PropertyValue -> [(T.Text, CyVal)]
pageScalarProps props = concatMap flattenKV (HM.toList props)
  where
    flattenKV (k,v) =
      case v of
        PVTitle _         -> []
        PVRichText rts    -> [(sanitizeProp k, CyS (T.concat (map rtPlain rts)))]
        PVNumber mn       -> maybe [] (\n -> [(sanitizeProp k, CyN n)]) mn
        PVCheckbox b      -> [(sanitizeProp k, CyB b)]
        PVUrl mt          -> maybe [] (\t -> [(sanitizeProp k, CyS t)]) mt
        PVEmail mt        -> maybe [] (\t -> [(sanitizeProp k, CyS t)]) mt
        PVPhone mt        -> maybe [] (\t -> [(sanitizeProp k, CyS t)]) mt
        PVDate md         -> case md of
                               Nothing -> []
                               Just (DateRange s e tz) ->
                                 [ (sanitizeProp (k <> "_start"), CyS s) ]
                                 <> maybe [] (\x -> [(sanitizeProp (k <> "_end"), CyS x)]) e
                                 <> maybe [] (\x -> [(sanitizeProp (k <> "_tz"),  CyS x)]) tz
        PVFormula fv      -> formulaKVs k fv
        PVUniqueId (UniqueId mp mn) ->
          maybe [] (\x -> [(sanitizeProp (k <> "_prefix"), CyS x)]) mp
          <> maybe [] (\x -> [(sanitizeProp (k <> "_number"), CyN x)]) mn
        PVStatus mo       -> case mo of
                               Nothing -> []
                               Just (SelectOption _ name _) -> [(sanitizeProp k, CyS name)]
        PVSelect mo       -> case mo of
                               Nothing -> []
                               Just (SelectOption _ name _) -> [(sanitizeProp k, CyS name)]
        PVMultiSelect os  ->
          let names = map (\(SelectOption _ n _) -> CyS n) os
          in if null names then [] else [(sanitizeProp (k <> "_list"), CyL names)]
        PVFiles fs        ->
          let urls = [ CyS u | FileRef _ u <- fs ]
          in if null urls then [] else [(sanitizeProp (k <> "_urls"), CyL urls)]
        PVPeople _        -> []
        PVRelation _      -> []
        PVCreatedTime mt  -> maybe [] (\t -> [(sanitizeProp k, CyS t)]) mt
        PVLastEditedTime mt-> maybe [] (\t -> [(sanitizeProp k, CyS t)]) mt
        PVCreatedBy mu    -> maybe [] (\(UserLite i n tt) ->
                                  [(sanitizeProp (k <> "_id"), CyS i)]
                                  <> maybe [] (\x -> [(sanitizeProp (k <> "_name"), CyS x)]) n
                                  <> maybe [] (\x -> [(sanitizeProp (k <> "_type"), CyS x)]) tt) mu
        PVLastEditedBy mu -> maybe [] (\(UserLite i n tt) ->
                                  [(sanitizeProp (k <> "_id"), CyS i)]
                                  <> maybe [] (\x -> [(sanitizeProp (k <> "_name"), CyS x)]) n
                                  <> maybe [] (\x -> [(sanitizeProp (k <> "_type"), CyS x)]) tt) mu
        PVUnsupported _ _ -> []
    formulaKVs k = \case
      FvString ms -> maybe [] (\s -> [(sanitizeProp k, CyS s)]) ms
      FvNumber mn -> maybe [] (\n -> [(sanitizeProp k, CyN n)]) mn
      FvBool   mb -> maybe [] (\b -> [(sanitizeProp k, CyB b)]) mb
      FvDate   md -> case md of
        Nothing -> []
        Just (DateRange s e tz) ->
          [ (sanitizeProp (k <> "_start"), CyS s) ]
          <> maybe [] (\x -> [(sanitizeProp (k <> "_end"), CyS x)]) e
          <> maybe [] (\x -> [(sanitizeProp (k <> "_tz"),  CyS x)]) tz
      FvUnknown _ -> []

emitRelationRels :: T.Text -> T.Text -> HM.HashMap T.Text PropertyValue -> [T.Text]
emitRelationRels pageLabel pid props =
  concatMap one (HM.toList props)
  where
    one (k, PVRelation rs) =
      [ T.concat
        [ "MATCH (p:", sanitizeLabel pageLabel, " {id: ", emitString pid, "})\n"
        , "MERGE (q:", sanitizeLabel pageLabel, " {id: ", emitString (rrId r), "})\n"
        , "MERGE (p)-[:", "REL__", sanitizeRel k, "]->(q);\n"
        ]
      | r <- rs
      ]
    one _ = []

emitPeopleRels :: T.Text -> T.Text -> HM.HashMap T.Text PropertyValue -> [T.Text]
emitPeopleRels pageLabel pid props =
  concatMap one (HM.toList props)
  where
    one (k, PVPeople us) =
      [ T.concat
        [ "MATCH (p:", sanitizeLabel pageLabel, " {id: ", emitString pid, "})\n"
        , "MERGE (u:NotionUser {id: ", emitString (uId u), "})\n"
        , maybe "" (\nm -> T.concat ["SET u.name = ", emitString nm, "\n"]) (uName u)
        , maybe "" (\tp -> T.concat ["SET u.user_type = ", emitString tp, "\n"]) (uType u)
        , "MERGE (p)-[:", "HAS_PERSON__", sanitizeRel k, "]->(u);\n"
        ]
      | u <- us
      ]
    one _ = []

emitSelectRels :: T.Text -> T.Text -> HM.HashMap T.Text PropertyValue -> [T.Text]
emitSelectRels pageLabel pid props =
  concatMap one (HM.toList props)
  where
    emitOpt k opt =
      T.concat
        [ "MATCH (p:", sanitizeLabel pageLabel, " {id: ", emitString pid, "})\n"
        , "MERGE (o:NotionOption {id: ", emitString (soId opt), "})\n"
        , "SET o.name = ", emitString (soName opt), "\n"
        , maybe "" (\c -> T.concat ["SET o.color = ", emitString c, "\n"]) (soColor opt)
        , "SET o.property = ", emitString k, "\n"
        , "MERGE (p)-[:", "HAS_OPTION__", sanitizeRel k, "]->(o);\n"
        ]
    one (k, PVSelect (Just o)) = [emitOpt k o]
    one (k, PVStatus (Just o)) = [emitOpt k o]
    one (k, PVMultiSelect os)  = map (emitOpt k) os
    one _ = []
