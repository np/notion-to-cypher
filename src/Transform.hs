{-# LANGUAGE OverloadedStrings #-}
{-# LANGUAGE LambdaCase #-}
module Transform (transformToCypher) where

import           Notion.Model
import           Cypher.Emit
import qualified Data.HashMap.Strict as HM
import qualified Data.Text as T

transformToCypher :: T.Text -> DatabaseQuery -> T.Text
transformToCypher pageLabel dq =
  T.intercalate "\n" $
    [ "/* generated by notion-to-memgraph */" ] ++
    concatMap (emitPage pageLabel) (dqResults dq)

emitPage :: T.Text -> Page -> [T.Text]
emitPage pageLabel p =
  let lblPage = quote pageLabel
      pageNode = T.concat
        [ "MERGE (p:", lblPage, " {id: ", emitString (pageId p), "})"
        , "\nSET p += "
        , emitMap (pageBaseProps p <> pageScalarProps (pageProperties p))
        , "\n"
        ]
      rels = concat
        [ emitSelectRels pageLabel (pageId p) (pageProperties p)
        , emitPeopleRels pageLabel (pageId p) (pageProperties p)
        , emitRelationRels pageLabel (pageId p) (pageProperties p)
        ]
  in [pageNode] <> rels

pageBaseProps :: Page -> [(T.Text, CyVal)]
pageBaseProps p =
  [ ("url",      CyS (pageUrl p))
  , ("archived", CyB (pageArchived p))
  , ("created_time", CyS (pageCreatedTime p))
  , ("last_edited_time", CyS (pageLastEdited p))
  ] <> maybeTitle
  where
    maybeTitle =
      case firstTitle (pageProperties p) of
        Nothing -> []
        Just t  -> [("title", CyS t)]

firstTitle :: HM.HashMap T.Text PropertyValue -> Maybe T.Text
firstTitle props =
  let titles = [ T.concat (map rtPlain rts) | PVTitle rts <- HM.elems props ]
  in case titles of
       (x:_) -> Just x
       _     -> Nothing

pageScalarProps :: HM.HashMap T.Text PropertyValue -> [(T.Text, CyVal)]
pageScalarProps props = concatMap flattenKV (HM.toList props)
  where
    flattenKV (k,v) =
      case v of
        PVTitle _         -> []
        PVRichText rts    -> [(k, CyS (T.concat (map rtPlain rts)))]
        PVNumber mn       -> maybe [] (\n -> [(k, CyN n)]) mn
        PVCheckbox b      -> [(k, CyB b)]
        PVUrl mt          -> maybe [] (\t -> [(k, CyS t)]) mt
        PVEmail mt        -> maybe [] (\t -> [(k, CyS t)]) mt
        PVPhone mt        -> maybe [] (\t -> [(k, CyS t)]) mt
        PVDate md         -> case md of
                               Nothing -> []
                               Just (DateRange s e tz) ->
                                [ (k <> "_start", CyS s) ]
                                <> maybe [] (\x -> [(k <> "_end", CyS x)]) e
                                <> maybe [] (\x -> [(k <> "_tz",  CyS x)]) tz
        PVFormula fv      -> formulaKVs k fv
        PVUniqueId (UniqueId mp mn) ->
          maybe [] (\x -> [(k <> "_prefix", CyS x)]) mp
          <> maybe [] (\x -> [(k <> "_number", CyN x)]) mn
        PVStatus mo       -> case mo of
                               Nothing -> []
                               Just (SelectOption _ name _) -> [(k, CyS name)]
        PVSelect mo       -> case mo of
                               Nothing -> []
                               Just (SelectOption _ name _) -> [(k, CyS name)]
        PVMultiSelect os  ->
          let names = map (\(SelectOption _ n _) -> CyS n) os
          in if null names then [] else [(k <> "_list", CyL names)]
        PVFiles fs        ->
          let urls = [ CyS u | FileRef _ u <- fs ]
          in if null urls then [] else [(k <> "_urls", CyL urls)]
        PVPeople _        -> []
        PVRelation _      -> []
        PVCreatedTime mt  -> maybe [] (\t -> [(k, CyS t)]) mt
        PVLastEditedTime mt-> maybe [] (\t -> [(k, CyS t)]) mt
        PVCreatedBy mu    -> maybe [] (\(UserLite i n tt) ->
                                  [(k <> "_id", CyS i)]
                                  <> maybe [] (\x -> [(k <> "_name", CyS x)]) n
                                  <> maybe [] (\x -> [(k <> "_type", CyS x)]) tt) mu
        PVLastEditedBy mu -> maybe [] (\(UserLite i n tt) ->
                                  [(k <> "_id", CyS i)]
                                  <> maybe [] (\x -> [(k <> "_name", CyS x)]) n
                                  <> maybe [] (\x -> [(k <> "_type", CyS x)]) tt) mu
        PVUnsupported _ _ -> []
    formulaKVs k = \case
      FvString ms -> maybe [] (\s -> [(k, CyS s)]) ms
      FvNumber mn -> maybe [] (\n -> [(k, CyN n)]) mn
      FvBool   mb -> maybe [] (\b -> [(k, CyB b)]) mb
      FvDate   md -> case md of
        Nothing -> []
        Just (DateRange s e tz) ->
          [ (k <> "_start", CyS s) ]
          <> maybe [] (\x -> [(k <> "_end", CyS x)]) e
          <> maybe [] (\x -> [(k <> "_tz",  CyS x)]) tz
      FvUnknown _ -> []

emitRelationRels :: T.Text -> T.Text -> HM.HashMap T.Text PropertyValue -> [T.Text]
emitRelationRels pageLabel pid props =
  concatMap one (HM.toList props)
  where
    one (k, PVRelation rs) =
      [ T.concat
        [ "MATCH (p:", quote pageLabel, " {id: ", emitString pid, "})\n"
        , "MERGE (q:", quote pageLabel, " {id: ", emitString (rrId r), "})\n"
        , "MERGE (p)-[:", quote ("REL__" <> k), "]->(q)\n"
        ]
      | r <- rs
      ]
    one _ = []

emitPeopleRels :: T.Text -> T.Text -> HM.HashMap T.Text PropertyValue -> [T.Text]
emitPeopleRels pageLabel pid props =
  concatMap one (HM.toList props)
  where
    one (k, PVPeople us) =
      [ T.concat
        [ "MATCH (p:", quote pageLabel, " {id: ", emitString pid, "})\n"
        , "MERGE (u:NotionUser {id: ", emitString (uId u), "})\n"
        , maybe "" (\nm -> T.concat ["SET u.name = ", emitString nm, "\n"]) (uName u)
        , maybe "" (\tp -> T.concat ["SET u.user_type = ", emitString tp, "\n"]) (uType u)
        , "MERGE (p)-[:", quote ("HAS_PERSON__" <> k), "]->(u)\n"
        ]
      | u <- us
      ]
    one _ = []

emitSelectRels :: T.Text -> T.Text -> HM.HashMap T.Text PropertyValue -> [T.Text]
emitSelectRels pageLabel pid props =
  concatMap one (HM.toList props)
  where
    emitOpt k opt =
      T.concat
        [ "MATCH (p:", quote pageLabel, " {id: ", emitString pid, "})\n"
        , "MERGE (o:NotionOption {id: ", emitString (soId opt), "})\n"
        , "SET o.name = ", emitString (soName opt), "\n"
        , maybe "" (\c -> T.concat ["SET o.color = ", emitString c, "\n"]) (soColor opt)
        , "SET o.property = ", emitString k, "\n"
        , "MERGE (p)-[:", quote ("HAS_OPTION__" <> k), "]->(o)\n"
        ]
    one (k, PVSelect (Just o)) = [emitOpt k o]
    one (k, PVStatus (Just o)) = [emitOpt k o]
    one (k, PVMultiSelect os)  = map (emitOpt k) os
    one _ = []
